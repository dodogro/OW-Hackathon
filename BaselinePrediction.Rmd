---
title: "Forecasting Baseline"
output: html_document
date: "2023-03-04"
---
Setting path
NOTE: In order to run the script smoothly we recommend to have saved the folder
containing all the data sets in a separate folder called "Data-OW"

```{r Path Setting}
path = "../Data-OW/"
```

Importing libraries
```{r Importing Libraries and parameters setting}
pacman::p_load(readxl,lubridate,dplyr,timechange,stringr, 
               ggplot2, ggrepel, tidyverse, ggcharts, car, forecast, scales, tidyquant, 
               gridExtra, tibbletime, itsmr, here, fpp2, tseries)

# Removing scientific notation

options(scipen=999)
```

```{r Loading the necessary data}

load(paste0(path, "MergedData.RData"))
cpi.df <- read_xlsx(paste0(path, "Consumer Price Index_vShared.xlsx"))
holiday.df <- read.table(paste0(path,"Hackathon_HolidaysMY_vShared.csv"), 
                                       header = TRUE,
                                       sep = ",")

```

```{r Brief Data sets preparation}

cpi.df$Date_daily <- as.character(cpi.df$Date_daily)
cpi.df$Date_daily <- as.POSIXct(cpi.df$Date_daily, 
                                format = "%Y-%m-%d",
                                tz = time_at_tz(Sys.timezone(location = TRUE)))

cpi.df<- cpi.df[between(cpi.df$Date_daily, as.POSIXct("2020-01-01"), as.POSIXct("2022-12-31")),]
```
Note one thing from this plot: 4 Products are displayed where two, namely 49329 and 49333 have been bought
every single day throughout the 3 years. On the other hand 49340, has been bought 1039 (57 days without have been purchased) and 49341 "just" 896 times. In these cases we will have to force such dates with "0" volumes sold. 
```{r Creating Prediction Dataset}
Date <-as.data.frame(cpi.df[,3:4]) # Required to be sure to have all the dates in the following data set
colnames(Date) <- c("Date", "CPI_daily")
Date$Weekday <- factor(weekdays(Date$Date), levels = c("Monday", "Tuesday", "Wednesday",
                                                       "Thursday", "Friday", "Saturday", "Sunday"))
Date$WeekendFlag[Date$Weekday == "Saturday" | Date$Weekday == "Sunday"] <- "TRUE"
Date$WeekendFlag[which(is.na(Date$WeekendFlag))] <- "FALSE"
Date$WeekendFlag <- factor(Date$WeekendFlag, levels = c("TRUE", "FALSE"))
```

```{r Creating the dataset for the model}
# Filtering by ProductKey
product.code.filter <- c("49340")

sales <- transaction.df %>% 
  select(ProductKey, TransactionDate, UnitVolume, ActualSales, SalesDiscount,
         RetailFullPrice, DistributionChannel) %>% 
  filter(DistributionChannel == "Physical" &
           ProductKey %in% product.code.filter) %>% 
  mutate(PromoFlag = case_when((abs(SalesDiscount)/RetailFullPrice) > 0.05 ~ 1,
                               TRUE ~ 0)) %>% 
  filter(PromoFlag == 0) %>% 
  group_by(TransactionDate, ProductKey) %>% 
  summarise(SumDiscounts = sum(SalesDiscount),
            SumFullPrices = sum(RetailFullPrice),
            TotVolumes = sum(UnitVolume)) %>% 
  ungroup()

df <- left_join(Date, sales, by = c("Date" = "TransactionDate"))
df$ProductKey <- droplevels(df$ProductKey)
df$ProductKey[which(is.na(df$ProductKey))] <- product.code.filter
df$SumDiscounts[which(is.na(df$SumDiscounts))] <- 0
df$SumFullPrices[which(is.na(df$SumFullPrices))] <- 0
df$TotVolumes[which(is.na(df$TotVolumes))] <- 0

# Check for missing values
summary(df) # No missing values
```


```{r Adding Exogenous factors}

# Holidays
# Data Frame Creation on the basis of holidays.df

holidays <- stack(as.data.frame(cbind(rep("Chinese New Years Day",4),
                                rep("Federal Territory Day",4),
                                rep("Hari Raya Puasa (End of Ramadan)",4),
                                rep("Labor Day",4),
                                rep("Wesak Day (Buddhas Birthday), Kings Birthday",4),
                                rep("Hari Raya Qurban (Feast of Sacrifice)",4),
                                rep("Awal Muharram (Islamic New Year)",4),
                                rep("Merdeka Day (National Day)",4),
                                rep("Milad un Nabi (Birth of the Prophet Muhammad)",4),
                                rep("Deepavali (Festival of Lights)",4),
                                rep("Christmas Day",4))))

Date_holidays <- stack(as.data.frame(cbind(c("2020-01-22", "2021-01-22", "2022-01-22", "2023-01-22"),
                                  c("2020-02-01", "2021-02-01", "2022-02-01", "2023-02-01"),
                                  c("2020-05-24", "2021-05-13", "2022-05-02", "2023-04-22"),
                                  c("2020-05-01", "2021-05-01", "2022-05-01", "2023-05-01"),
                                  c("2020-05-26", "2021-05-26", "2022-05-26", "2023-05-26"),
                                  c("2020-06-31", "2021-07-20", "2022-07-10", "2023-06-29"),
                                  c("2020-08-20", "2021-08-09", "2022-06-30", "2023-07-19"),
                                  c("2020-08-31", "2021-08-31", "2022-08-31", "2023-08-31"),
                                  c("2020-10-28", "2021-10-18", "2022-10-07", "2023-09-26"),
                                  c("2020-11-14", "2021-11-04", "2022-10-24", "2023-10-12"),
                                  c("2020-12-25", "2021-12-25", "2022-12-25", "2023-12-25"))))

holidays.df <- cbind(holidays, Date_holidays)[,-c(2,4)]
colnames(holidays.df) <- c("Festivity", "Date")

holidays.df$Date<- as.POSIXct(holidays.df$Date, format = "%Y-%m-%d",  
                              tz = time_at_tz(Sys.timezone(location = TRUE)))

df <- left_join(df, holidays.df, by = "Date")
df <- df %>% 
  mutate(Festivity = case_when(is.na(Festivity) ~ 0,
                   TRUE ~ 1))
df$Festivity <- as.factor(df$Festivity)

# Checking
table(df$Festivity)
```

```{r Completed Data set for Baseline Predction and related Plot}
View(df)
```
```{r}
ggplot(data = df,
       aes(x = Date, y = TotVolumes, group = ProductKey,
                                colour = factor(ProductKey))) +
  geom_line(linetype = "solid") +
  #geom_point() +
  geom_hline(yintercept = mean(df$TotVolumes)) +
  ylab("TotVolumes") +
  xlab("Date") +
  theme(legend.title = element_blank())
```
It looks like our time series is highly autocorrelated. Is it stationary though? 
According to what the ACF displays, it seems the process is non-stationary. We will deal with it with differentiation hoping it will resolve the problem

```{r ACF}
ggAcf(df$TotVolumes, lag.max = 104)
ggPacf(df$TotVolumes)
```
```{r SARIMAX}
baseline_SARIMAX = auto.arima(as.vector(df[,"TotVolumes"]), # specify main trend
                              xreg = data.matrix(df[,c("CPI_daily", "WeekendFlag", "Festivity")]), # specify exogenous variables here
                              trace = TRUE,
                              seasonal= TRUE, # allow a SARIMAX model
                              stepwise=FALSE,
                              approximation=FALSE)
```
```{r Testing}
checkresiduals(baseline_SARIMAX)
test(resid(baseline_SARIMAX))
autoplot(baseline_SARIMAX)
```

```{r Forecasting}

# split the data into train and test sets
baseline_train <- df %>% filter(Date <= as.POSIXct("2022-06-01", format = "%Y-%m-%d",  
                              tz = time_at_tz(Sys.timezone(location = TRUE))))
                              
baseline_test <- df %>% filter(Date > as.POSIXct("2022-06-01", format = "%Y-%m-%d",  
                              tz = time_at_tz(Sys.timezone(location = TRUE))))

# retrain model only on train data
baseline_arimax = auto.arima(as.vector(baseline_train[,"TotVolumes"]), # specify main trend
                              xreg = data.matrix(baseline_train[,c("CPI_daily",
                                                                   "WeekendFlag",
                                                                   "Festivity")]), # specify exogenous variables here
                              trace = TRUE,
                              seasonal= TRUE, # allow a SARIMAX model
                              stepwise=FALSE,
                              approximation=FALSE)

## produce forecasts
myforecasts <- forecast::forecast(baseline_arimax, xreg=data.matrix(baseline_test[,c("CPI_daily",
                                                                   "WeekendFlag",
                                                                   "Festivity")]),)

## plot the forecasts
autoplot(myforecasts) + autolayer(ts(df[,c("TotVolumes")]))
```

