---
title: "Data Cleaning"
output: html_notebook
---
Setting path
NOTE: In order to run the script smoothly we recommend to have saved the folder
containing all the data sets in a separate folder called "Data-OW"
```{r Path Setting}
path = "../Data-OW/"
```

Importing libraries
```{r Importing Libraries and parameters setting}
pacman::p_load(readxl,lubridate,dplyr,timechange,stringr,shinydashboard, 
               shiny, ggplot2, shinythemes, ggrepel, tidyverse, shinyWidgets,
               vtable)

# Removing scientific notation

options(scipen=999)
```

___________________________________________________
# DimProduct dataset

Setting the working directory and importing the datasets
```{r Laoding Product.df}
head(product.df <- read.csv(paste0(path,"Hackathon_DimProduct_SAN_vShared.csv"), 
                       header = TRUE), 10)
str(product.df)
```

Cleaning ProductKey Column
Note on RegEx: (i?) is used to render the match case insensitive
```{r Cleaning ProductKey}
product.df$ProductKey <- gsub("(i?)key_", "", product.df$ProductKey)
length(product.df$ProductKey)

# OK
```

Cleaning Product Sub-Category column. Indeed, lv2. has some categories that needs to be transformed from lower case to upper case before the substitution.
Note on RegEx used: - (\\w*) = takes every word up to infinite times
                    - (\\s)  = considers the first space present in the string
                    - Combination of the two = Take all the words before a space (included)
```{r Cleaing Product Category}
product.df$ProductCategory_Lvl1 <- toupper(gsub("(\\w*\\s)", "", 
                                        product.df$ProductCategory_Lvl1))

product.df$ProductCategory_Lvl2 <- toupper(gsub("(\\w*\\s)", "", 
                                        product.df$ProductCategory_Lvl2))

# toUpper has been used as remedy to the difference in case present
# in the vectors
```

Transforming categories into factors
```{r Factorization}
product.df$ProductCategory_Lvl1 <- as.factor(product.df$ProductCategory_Lvl1)
product.df$ProductCategory_Lvl2 <- as.factor(product.df$ProductCategory_Lvl2)
```

____________________
Quick exploration of categories
```{r Exploration}
table(product.df$ProductCategory_Lvl1) # Only Category A
```

At lv.1 only A category is present in the dataset

```{r Exploration}
table(product.df$ProductCategory_Lvl2)
```
Product suppliers
```{r Exploration}
length(unique(product.df$SupplierKey))
```
There are 17 Product suppliers

________________________________________________________________________________
# CPI dataset

```{r Loaging CPI.df} 
head(cpi.df <- read_xlsx(paste0(path, "Consumer Price Index_vShared.xlsx")))
```
Understanding type of variables
```{r Overview}
str(cpi.df)
```

Setting up the date format for CPI
```{r Date format induction}
cpi.df$Date_daily <- as.character(cpi.df$Date_daily)
cpi.df$Date_daily <- as.POSIXct(cpi.df$Date_daily, 
                                format = "%Y-%m-%d",
                                tz = time_at_tz(
                                  Sys.timezone(location = TRUE)))
```


```{r Overview}
summary(cpi.df)
```

Most of monthly data are missing, thus the information must be reconstructed starting from the daily data. We have noticed that the monthly CPI index is constructed by simply taking the first-of-the-month index. Is it correct though? 
Idea: creating the correspondence between month and year, and computing the monthly CPI as the mean of the daily CPI

```{r Reproducing CPI monthly as daily average}
# Creating Date_Monthly and CPI_monthly columns
head(cpi.df1 <- cpi.df %>% 
     group_by(month(Date_daily), year(Date_daily)) %>% 
     mutate(Date_monthly1 = paste0(year(Date_daily),"-",month(Date_daily),"-01"),
             CPI_monthly1 = mean(CPI_daily)))

cpi.df1 <- cpi.df1 %>% 
  ungroup() %>% 
  select(Date_monthly1, CPI_monthly1, Date_daily, CPI_daily)

# Creating the date format for Date_monthly1
cpi.df1$Date_monthly1 <- as.POSIXct(cpi.df1$Date_monthly1,
                                    format = "%Y-%m-%d",
                                    tz = time_at_tz(
                                      Sys.timezone(location = TRUE)))

# Correcting columns name
colnames(cpi.df1) <- c("Date_monthly",
                       "CPI_monthly",
                       "Date_daily",
                       "CPI_daily")
```

Clearing the environment and final check
```{r Environment Clearnance}
# For sake of keeping the same data sets' names
cpi.df <- cpi.df1
remove(cpi.df1)

# Final check
str(cpi.df)

# OK
```

IMPORTANT NOTE:
There is a slight difference in monthly CPI computed as the mean of daily values and the one provided by the data due to the reason stated above. 

___________________________________________________
# Promotion dataset

```{r Laoding Promotion.df}
head(promotion.df <- read.table(paste0(path,"Hackathon_DimPromotion_SAN_vShared.csv"), 
                                header = TRUE,
                                sep = ","))
str(promotion.df)
```

Transforming PromotionKey into character (might be transformed into factor later)
```{r Characterization}
promotion.df$PromotionKey <- as.character(promotion.df$PromotionKey)
```

Transforming Promotion Dates into POSIXct formats
```{r Dates as.Date}
promotion.df$PromotionStartDate <- as.POSIXct(promotion.df$PromotionStartDate,
                                              format = "%m/%d/%Y",
                                              tz = time_at_tz(
                                                Sys.timezone(location = TRUE)))

promotion.df$PromotionEndDate <- as.POSIXct(promotion.df$PromotionEndDate,
                                            format = "%m/%d/%Y",
                                            tz = time_at_tz(
                                              Sys.timezone(location = TRUE)))
```

Transforming promotion mechanics into factor
```{r Factorization}
promotion.df$PromoMechanic <- as.factor(promotion.df$PromoMechanic)
table(promotion.df$PromoMechanic)
```
There are 15 promotion types + 1 unknown

```{r Overview}
summary(promotion.df)
```
No missing values

OK

____________________________________________-
# Store Dataset

```{r Laoding Store.df}
head(store.df <- read.table(paste0(path, 
                                   "Hackathon_DimStore_SAN_vShared.csv"), 
                           header = TRUE,
                           sep = ","))
```

```{r Overview}
str(store.df)
```

Transforming StoreKey and DistributionChannel into factors
```{r Factorization}
store.df$StoreKey <- as.factor(store.df$StoreKey)
store.df$DistributionChannel <- as.factor(store.df$DistributionChannel)
```


Adjusting StoreType and transforming it into factor
Note on RegEx: (\S+\s\S+) serves two take the first two words in the string, where \\S+ is the negation of \s, thus taking all the words excluding the space and \\s considers exactly the spaces. The combination takes thus exactly the first two words before a second space 

```{r Cleaning miswritten data entries}
store.df$StoreType <- gsub("(\\S+\\s\\S+)", "", store.df$StoreType)
store.df$StoreType <- as.factor(store.df$StoreType)
```

Adjusting Region_lvl 1 and 2 and transforming into factors
Note on RegEx: - [A-Z](?!.*[A-Z].* takes just the last capital letter
               - \\d+ is takes just the first group of number
```{r Cleaning miswritten data entries}
store.df$Region_Lvl1 <- str_extract(store.df$Region_Lvl1, "[A-Z](?!.*[A-Z].*)")
store.df$Region_Lvl2 <- str_extract(store.df$Region_Lvl2, "\\d+")

store.df$Region_Lvl1 <- as.factor(store.df$Region_Lvl1)
store.df$Region_Lvl2 <- as.factor(store.df$Region_Lvl2)
```

Final check
```{r Exploration}
table(store.df$Region_Lvl1)
as.data.frame(table(store.df$Region_Lvl2))

```

OK
_____________________________________
# Trasaction Dataset

```{r Laoding Transaction.df}
head(transaction.df <- read.table(paste0(path,
                       "Hackathon_FactSalesTransactionDATES_vShared.csv"),
                                  header = TRUE,
                                  sep = ","))
```

```{r Overview}
str(transaction.df)
```
During the analysis we noticed a mismatch between transaction.df, store.df and product.df due to a mismatch in the expression of the keys, so we make a few adjustments before proceeding
```{r StoreKey adjustment}
transaction.df$StoreKey <-  gsub("_Key", "", transaction.df$StoreKey)
```

```{r ProductKey adjustment}
transaction.df$ProductKey <- gsub("Key", "", transaction.df$ProductKey)
```


Trasforming TransactionDate into POSIXct format (it takes a while)
```{r Dates as.Date}
head(transaction.df$TransactionDate <- as.POSIXct(transaction.df$TransactionDate,format = "%Y-%m-%d",
                                                  tz = time_at_tz(
                                                Sys.timezone(location = TRUE))
                                                )
     )

```

Transforming DayOfWeek, WeekendFlag, StoreKey and ProductKey into factors
```{r Factorization}
transaction.df$DayOfWeek <- as.factor(transaction.df$DayOfWeek)
transaction.df$WeekendFlag <- as.factor(transaction.df$WeekendFlag)
transaction.df$StoreKey <- as.factor(transaction.df$StoreKey)
transaction.df$ProductKey <- as.factor(transaction.df$ProductKey)
```

```{r Overview}
summary(transaction.df)
```

# 23978 missing values
Check what 23978 missing values are treated as characters
```{r Testing}
test1 <- transaction.df$TransactionDate
test2 <- transaction.df$TransactionDate

test1 <- as.POSIXct(test1,
                    format = "%Y-%m-%d",
                    tz = "")

verifica <- test2[which(is.na(test1))]

head(verifica)
```

Testing if the same problem is replicated also for other character variables different from date
```{r Looking for the NAs}
names(transaction.df)
length(which(transaction.df$DayOfWeek == ""))
length(which(transaction.df$WeekendFlag == ""))
```

A recurrent pattern of "" for 23978 observation is present
-> Deleting those observations from the dataset

```{r Removing "" values}
transaction.df <- transaction.df %>% 
  filter(as.character(TransactionDate) != "")
```



Checking again the summary
```{r Overview}
summary(transaction.df)
```
There are still 72125 missing values in ActualSales

# 72125 missing ActualSales

```{r Testing}
test1 <- transaction.df %>% 
  filter(is.na(transaction.df$ActualSales))

summary(test1)
```

By comparing the two summaries we can see that the full dataset entails SalesDiscount both negative and positive while the subset of transactions where the "ActualSales" are missing has only negative discounts.
-> We can derive: ActualSales = RetailFullPrice + (-SalesDiscount)
since SalesDiscount for missing ActualSales has only negative values

We will later explore positive values of sales discount

Deriving missing ActualSales
```{r NAs imputation}
head(transaction.df$ActualSales[is.na(transaction.df$ActualSales)] <- transaction.df$RetailFullPrice[is.na(transaction.df$ActualSales)] 
+ transaction.df$SalesDiscount[is.na(transaction.df$ActualSales)])
```

Checking again the summary
```{r Overivew}
summary(transaction.df)
```
No more missing values 

```{r}
remove(test1)
```

OK
________________________________________________________________________________
# Trasaction Promotion Data set
```{r Laoding Transaction.Promotion.df}
head(transaction.promotion.df <-read.table(paste0(path,
                                             "Hackathon_FactSalesTransactionPromotion_vShared.csv"),
                                       header = TRUE,
                                       sep = ","))
```

Transforming TransactionDate into POSIXct format
```{r Dates as.Date}
transaction.promotion.df$TransactionDate <- as.POSIXct(transaction.promotion.df$TransactionDate,
                                                       format = "%Y-%m-%d",
                                                       tz = time_at_tz(
                                                         Sys.timezone(location = TRUE)))


```

Transforming StoreKey, ProductKey and Promotion Key into factors
```{r Factorization}
transaction.promotion.df$StoreKey <- as.factor(transaction.promotion.df$StoreKey)
transaction.promotion.df$ProductKey <- as.factor(transaction.promotion.df$ProductKey)
transaction.promotion.df$PromotionKey <- as.factor(transaction.promotion.df$PromotionKey)
```

```{r Overview}
summary(transaction.promotion.df)
```

```{r Creating splitting function specifically for transaction.df}

splitting_years <- function(transaction.df,start,end){
        return(transaction.df[between(transaction.df$TransactionDate, 
               as.POSIXct(start,
                          format = "%Y-%m-%d",
                          tz = time_at_tz(
                            Sys.timezone(location = TRUE))), 
               as.POSIXct(end,
                          format = "%Y-%m-%d",
                          tz = time_at_tz(
                            Sys.timezone(location = TRUE)))),])
  }
```

Removing 2012 relative data
```{r}
summary(transaction.df <- splitting_years(transaction.df, "2020-01-01","2022-12-31"))

# Now it's OK
```

_____________________________________
# Holiday

```{r Laoding Holiday.df}
head(holiday.df <- read.table(paste0(path,"Hackathon_HolidaysMY_vShared.csv"), 
                                       header = TRUE,
                                       sep = ","))
```
Why and which holidays could be important? We should search each period and merge the information


# Merging data sets
Note: Due to the immense data frame size, we are forced to work piecewise, otherwise
our machines will not able to function well. Moreover, since the transactions go from 2020.01.01 to 2022.12.31, it has been decided to remove the dates that were present concerning dates not in the 
scrutinized timespan

```{r Date as.Date}
cpi.df<- cpi.df[between(cpi.df$Date_daily, as.POSIXct("2020-01-01"), as.POSIXct("2022-12-31")),]

promotion.df <- promotion.df[between(promotion.df$PromotionStartDate, as.POSIXct("2020-01-01"), as.POSIXct("2022-12-31")),]

```

Now we will split the data frame transaction into 2020, 2021, and 2022
```{r Splitting transaction.df in years}
        
# For transactions
transactions2020 <- splitting_years(transaction.df, "2020-01-01", "2020-12-31")
transactions2021 <- splitting_years(transaction.df, "2021-01-01", "2021-12-31")
transactions2022 <- splitting_years(transaction.df, "2022-01-01", "2022-12-31")

```

__________________________________________________________________________-
# Transactions2020

Now it is possible to merge the subsets
```{r Merging 2020 transactions with all information}
# CPI
transactions2020 <- left_join(transactions2020, 
                              cpi.df,
                              by = c("TransactionDate" = "Date_daily"))

# Store
transactions2020 <- left_join(transactions2020,
                              store.df,
                              by = "StoreKey")

# Product
transactions2020 <- left_join(transactions2020,
                              product.df,
                              by = "ProductKey")

# Promotion Key
transactions2020 <- left_join(transactions2020,
                              transaction.promotion.df,
                              by = c("TransactionDate", "StoreKey", "ProductKey"))

# Promotion
transactions2020 <- left_join(transactions2020,
                              promotion.df,
                              by = "PromotionKey")

```

```{r Saving backup}
save(transactions2020, file = "transactions2020.RData")
```

## Exploration of missing values

IMPORTANT PREMISE:
The keys adjustments were done during the process of data transformation of the transaction.df, as a result the code that as a comment reported missing values should now report no missing values

```{r Summary}
summary(transactions2020)
```

14091 missing DistributionChannel and StoreType

```{r Missing distribution channels and store type}
head(unique(transactions2020$StoreKey[which(is.na(transactions2020$StoreType))]), 20)
```

It appears that "transaction.df" needs a correction in the way data are expressed
The same mistake is probably done also for "ProductKey"

11138 missing BrandKey, SupplierKey, ProductCategory
```{r Missing BrandKey}
head(unique(transactions2020$ProductKey[which(is.na(transactions2020$BrandKey))]), 20)
```

Final missing values check
```{r}
any(is.na(transactions2020[,1:20]))
```

No missing values in the first 20 columns

Now we have to check why we have a mismatch in PromotionKey. Apparently there are some promotions that have a key but no related information

```{r}
length(which(is.na(transactions2020$PromotionKey)))
```

2179539 transactions in 2020 were done without promotion

Now we are looking for the number of transactions that do not have a PromoMechanic but actually have a PromotionKey

```{r Number of no info promotion}
length(which(is.na(transactions2020$PromoMechanic[which(!is.na(transactions2020$PromotionKey))]))) 
```

281583 transactions were done with a promotion but there are no information related

```{r Further exploration of promotions missing values}
noinfo_promo <- transactions2020 %>% 
  filter(!is.na(PromotionKey)) %>% 
  filter(is.na(PromoMechanic)) %>% 
  select(ProductKey, PromotionKey, PromoMechanic, TransactionDate)

# Check the mismatch
mismatch <- left_join(promotion.df, 
                      noinfo_promo,
                      by = "PromotionKey")

any(!is.na(mismatch$ProductKey)) # No match detected 

remove(noinfo_promo, mismatch)
```

Why some promotions don't have the correspondent information? What can we do about them?

_________________________________________________________
# Interactive Dashboard
```{r Interactive Dashboard}
# Trial 
transaction.df.s <- merge(transaction.df, store.df)
transaction.df.p <- merge(transaction.df.m, product.df)
transaction.df.pr <- merge(transaction.df.m, transaction.promotion.df)
transaction.df.pr <- transaction.df.pr[-c(4,5,14)]
transaction.df <- merge(transaction.df.pr, promotion.df)

sales_volumes <- transaction.df %>% 
  select(TransactionDate, ActualSales, DistributionChannel, SalesDiscount, ProductCategory_Lvl2, StoreKey, UnitVolume, ProductKey, PromoMechanic, Region_Lvl1, Region_Lvl2, StoreType) %>% 
  filter(TransactionDate >= as.POSIXct("2020-01-01",format = "%Y-%m-%d", tz = ""))
```

```{r UI-Creation}

ui <- fluidPage(
  theme = shinytheme("flatly"),
  navbarPage( 
  title = "OW - Hackatow",
  tabPanel("Exploratory Analysis",
           sidebarPanel(
             tags$h3("Slicers"), # "h3" is the heading's size
             sliderInput(inputId = "Time", # Creating the slider on the side 
                         label = "Date",
                  min = as.POSIXct("2020-01-01", format = "%Y-%m-%d", tz = ""),
                  max = as.POSIXct("2022-12-31", format = "%Y-%m-%d", tz = ""),
                  value = c(min(sales_volumes$TransactionDate), 
                            max(sales_volumes$TransactionDate)),
                  timeFormat="%Y-%m-%d",
                  timezone = "+0100"),
             
              pickerInput(inputId = "ProductID",
                         label = "ProductKey",
                         choices = levels(sales_volumes$ProductKey),
                         options = list('actions-box' = TRUE,
                                        'liveSearch' = TRUE,
                                        'showTick' = TRUE),
                         multiple = TRUE,
                         selected = c("49340", "49341", "49333","49329")),
             
             checkboxGroupInput(inputId = "Channel",
                         label = "Channel",
                         choices = c("Online", "Physical"),
                         selected = c("Online", "Physical")),
             
             pickerInput(inputId = "StoreID",
                         label = "StoreKey",
                         choices = levels(sales_volumes$StoreKey),
                         options = list('actions-box' = TRUE,
                                        'liveSearch' = TRUE,
                                        'showTick' = TRUE),
                         multiple = TRUE,
                         selected = "2071"
                         ),
             
             checkboxGroupInput(inputId = "Category",
                         label = "Category",
                         choices = levels(sales_volumes$ProductCategory_Lvl2),
                         selected = "AC", 
                         inline = TRUE),
             
             pickerInput(inputId = "Promo",
                         label = "PromoMechanic",
                         choices = levels(sales_volumes$PromoMechanic),
                         options = list('actions-box' = TRUE,
                                        'liveSearch' = TRUE,
                                        'showTick' = TRUE),
                         multiple = TRUE,
                         selected = "Percentage off"),
             
             downloadButton(outputId = "report", 
                            label = "Generate report")
             ),
           
           mainPanel(
            tabsetPanel(type = "tabs",
              tabPanel(#splitLayout(cellWidths = c("60%", "20%", "20%")),
                                tags$p("Aggregate Sales Volumes"),
                                plotOutput(outputId = "SalesVolumes"),
                                # tags$p("Summary Statistics"),
                                #valueBoxOutput(outputId = "MeanDiscount"),
                                #valueBoxOutput(outputId = "MeanSale"),
                                valueBoxOutput(outputId = "TotalSales"),
                                valueBoxOutput(outputId = "TotalDiscount"),
                                valueBoxOutput(outputId = "Volumes")
                                ),
              
              tabPanel(tags$p("Volumes by PromoMechanic"),
                       plotOutput(outputId = "PromotionMechanism")
                       ),
              
              tabPanel(tags$p("Volumes by Stores"),
                       ggiraphOutput(outputId = "Store")
                       )
             )
           )
        )
      )
    )
    

```

```{r Server Creation}
server <- function(input, output){
  
  datasetInput <- reactive({
      sales_volumes %>% 
      filter(TransactionDate >= input$Time[1] & TransactionDate <= input$Time[2]) %>% 
      filter(DistributionChannel %in% input$Channel) %>% 
      filter(StoreKey %in% input$StoreID) %>% 
      filter(ProductCategory_Lvl2 %in% input$Category) %>%
      filter(ProductKey %in% input$ProductID) %>% 
      group_by(TransactionDate) %>% 
      summarise(Daily_Mean = mean(ActualSales),
                Daily_Sum = sum(ActualSales),
                Daily_Discount = -sum(SalesDiscount),
                Volumes = sum(UnitVolume))
    })
  
  datasetInput2 <- reactive({
      sales_volumes %>% 
      filter(TransactionDate >= input$Time[1] & TransactionDate <= input$Time[2]) %>% 
      filter(DistributionChannel %in% input$Channel) %>% 
      filter(StoreKey %in% input$StoreID) %>% 
      filter(ProductCategory_Lvl2 %in% input$Category) %>%
      filter(ProductKey %in% input$ProductID) %>% 
      group_by(TransactionDate, PromoMechanic, DistributionChannel) %>% 
      summarise(Daily_Mean = mean(ActualSales),
                Daily_Sum = sum(ActualSales),
                Daily_Discount = -sum(SalesDiscount),
                Volumes = sum(UnitVolume))
  })
  
  store.summary <- reactive({
    sales_volumes %>% 
    select(StoreKey, StoreType, Region_Lvl1, Region_Lvl2, ActualSales, TransactionDate) %>% 
    filter(TransactionDate >= input$Time[1] & TransactionDate <= input$Time[2]) %>% 
    group_by(StoreKey, StoreType, Region_Lvl1, Region_Lvl2) %>% 
    summarise(revenues = sum(ActualSales)) %>% 
    mutate(txt = paste("Store: ",StoreKey, "\n",
                        "Yearly sales: ", round(revenues/1000, digits = 0),"k€", "\n",
                        "Region lvl.1: ", Region_Lvl1, "\n",
                        "Region lvl.2: ", Region_Lvl2)) %>% 
    arrange(desc(revenues)) %>% 
    ungroup()
    
  })
  
  # BarPlot
  output$PromotionMechanism <- renderPlot({
    print(myplot2 <- ggplot(datasetInput2(), aes(x=DistributionChannel, 
                                                 y=Daily_Sum, fill=PromoMechanic)) +
    geom_bar(stat="identity", position=position_dodge()) +
   # geom_errorbar(aes(ymin=Daily_Sum, ymax=Daily_Sum), width=.2,
    #              position=position_dodge(.9)) + 
      scale_fill_brewer(palette="Paired") +        
      scale_x_discrete(guide = guide_axis(check.overlap = TRUE)) + 
      theme(panel.grid.major = element_blank(),
          # axis.line = element_line(colour = "black"),
            axis.title.x = element_blank(),
            axis.title.y = element_blank(),
            panel.background = element_rect(fill= NA),
            plot.background = element_rect(fill= NA)))
  })
  
  # Time Series
  output$SalesVolumes <- renderPlot({
    print(myplot <- ggplot(datasetInput(), aes(x = TransactionDate, y = Daily_Sum)) +
            geom_line(color = "deepskyblue4") + 
            geom_line(aes(x = TransactionDate, 
                          y = Daily_Discount*(max(Daily_Sum)/max(Daily_Discount))),
                      color = "yellow4") +
            scale_y_continuous(
            # Features of the first axis
            name = "AggregateSales",
            # Add a second axis and specify its features
            sec.axis = sec_axis(~.*max(datasetInput()$Daily_Sum)/max(datasetInput()$Daily_Discount), 
            name="AggregateDiscount")) +
            theme(# panel.grid.major = element_blank(),
                  # axis.line = element_line(colour = "black"),
                  axis.title.x = element_blank(),
                  axis.title.y = element_blank(),
                  panel.background = element_rect(fill=NA),
                  plot.background = element_rect(fill=NA)))
  })
  
  #output$MeanDiscount <- renderValueBox({
   # valueBox(subtitle = mean(datasetInput()$Daily_Discount),
    #         value = "MeanDailyDiscount (MYR)")
 # })
  
  #output$MeanSale <- renderValueBox({
   # valueBox(subtitle = mean(datasetInput()$Daily_Sum),
    #         value = "MeanDailySales (MYR)")
  #})
  
  output$Volumes <- renderValueBox({
     valueBox(subtitle = sum(datasetInput()$Volumes),
              value = "Volumes (Unit)",
              width = 4,
              color = "navy")
  })
  
   output$TotalDiscount <- renderValueBox({
     valueBox(subtitle = sum(datasetInput()$Daily_Discount),
              value = "TotDiscount (MYR)",
              width = 4, 
              color = "olive")
  })
   
   output$TotalSales<- renderValueBox({
     valueBox(subtitle = sum(datasetInput()$Daily_Sum),
              value = "TotSales (MYR)",
              width = 4,
              color = "green")
  })

   
  output$Store <- renderggiraph({
    packing <- circleProgressiveLayout(store.summary()$revenues, sizetype = "area")
    data <- cbind(store.summary(), packing)
    data.gg <- circleLayoutVertices(packing, npoints = 50)

    p <- ggplot() +
    geom_polygon_interactive(data = data.gg,
                             aes(x = x, y = y, group = id, fill = id,
                                 tooltip = data$txt[id], data_id = id),
                             colour = "black", alpha = 0.6) +
    scale_fill_viridis() +
    geom_text(data = data,
              aes(x = x, y = y, label = StoreKey),
              size = 2, colour = "black") +
    theme_void() + 
    theme(legend.position = "none") +
    coord_equal()
  
  # Interactive
  widg <- ggiraph(ggobj = p, width_svg = 7, height_svg = 7)
  widg
  })

}

```

```{r Dasboard at Glance}

shinyApp(ui, server)

```
```{r}
